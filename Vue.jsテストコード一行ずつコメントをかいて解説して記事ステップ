# 【新人エンジニア必見】Vue.jsテストコード文法完全解説：一行ずつコメント付きで理解する

新人エンジニアがVue.jsのテストコードを書く際に「なぜこう書くのか？」「この一行は何をしているのか？」という疑問を解決するため、テストコードの文法を一行ずつ詳しく解説します。

## 📋 1. 基本的なテストファイルの文法解説

### 1.1 基本的なインポート文

```javascript
// Vue Test Utils からテスト用の関数をインポート
import { mount, shallowMount } from '@vue/test-utils'
// ↑ mount: コンポーネントを完全にレンダリング（子コンポーネントも含む）
// ↑ shallowMount: コンポーネントを浅くレンダリング（子コンポーネントはスタブ化）

// テスト対象のVueコンポーネントをインポート
import Component from '@/components/Component.vue'
// ↑ @/ は src/ ディレクトリのエイリアス（webpack設定による）
// ↑ .vue 拡張子は Vue単一ファイルコンポーネントを示す
```

### 1.2 テストスイートの基本構造

```javascript
// describe: テストグループを定義する Jest の関数
describe('Component.vue', () => {
// ↑ 第1引数: テストグループの名前（通常はファイル名）
// ↑ 第2引数: テストを含むコールバック関数

  // wrapper: マウントされたコンポーネントを格納する変数
  let wrapper
  // ↑ let を使用することで、各テストで再代入可能にする

  // beforeEach: 各テストケース実行前に毎回実行される関数
  beforeEach(() => {
  // ↑ テストの独立性を保つため、各テスト前に初期化を行う

    // mount: コンポーネントをテスト環境でレンダリング
    wrapper = mount(Component, {
    // ↑ Component を第1引数に渡し、オプションを第2引数に渡す

      // propsData: コンポーネントに渡すプロパティ
      propsData: {
      // ↑ Vue 2.x での props 指定方法
        title: 'テストタイトル',  // プロパティ名: 値
        isActive: true            // ブール値も指定可能
      },

      // mocks: Vue インスタンスにモックオブジェクトを注入
      mocks: {
      // ↑ $store や $router などのグローバルオブジェクトをモック化
        $store: mockStore,        // Vuex ストアのモック
        $router: mockRouter       // Vue Router のモック
      }
    })
  })

  // afterEach: 各テストケース実行後に毎回実行される関数
  afterEach(() => {
  // ↑ メモリリークを防ぐためのクリーンアップ処理

    // destroy: マウントされたコンポーネントを破棄
    wrapper.destroy()
    // ↑ Vue 2.x でのコンポーネント破棄メソッド
    // ↑ イベントリスナーや監視者も自動的に削除される
  })

  // it: 個別のテストケースを定義する Jest の関数
  it('should render correctly', () => {
  // ↑ 第1引数: テストの説明（英語で書くのが一般的）
  // ↑ 第2引数: テスト内容を記述するコールバック関数

    // expect: Jest のアサーション関数
    expect(wrapper.exists()).toBe(true)
    // ↑ wrapper.exists(): コンポーネントが存在するかを確認
    // ↑ .toBe(true): 期待値が true であることを検証
  })
})
```

### 1.3 Vue 3 対応版の解説

```javascript
// Vue 3 では mount のみをインポート（shallowMount は非推奨）
import { mount } from '@vue/test-utils'
// ↑ Vue 3 用の @vue/test-utils を使用

// コンポーネントのインポートは同じ
import Component from '@/components/Component.vue'

describe('Component.vue', () => {
  let wrapper  // 変数宣言は同じ

  beforeEach(() => {
    // Vue 3 では mount の引数構造が変更された
    wrapper = mount(Component, {
      
      // props: Vue 3 では propsData から props に変更
      props: {
      // ↑ Vue 3 での新しい props 指定方法
        title: 'テストタイトル',
        isActive: true
      },

      // global: グローバル設定を一箇所にまとめる
      global: {
      // ↑ Vue 3 ではモックなどを global オブジェクト内に記述

        // mocks: モックオブジェクトの指定（Vue 2 と同じ）
        mocks: {
          $store: mockStore,
          $router: mockRouter
        }
      }
    })
  })

  afterEach(() => {
    // unmount: Vue 3 での新しいコンポーネント破棄メソッド
    wrapper.unmount()
    // ↑ destroy() から unmount() に変更された
  })

  // テストケース自体は Vue 2 と同じ
  it('should render correctly', () => {
    expect(wrapper.exists()).toBe(true)
  })
})
```

## 🎯 2. よく使うアサーション文法解説

### 2.1 存在・表示確認の文法

```javascript
// 要素の存在確認
expect(wrapper.find('.class-name').exists()).toBe(true)
// ↑ wrapper.find(): CSS セレクタで要素を検索
// ↑ .class-name: CSS クラスセレクタ（ドット記法）
// ↑ .exists(): 要素が DOM に存在するかを真偽値で返す
// ↑ .toBe(true): 厳密等価（===）で true と比較

expect(wrapper.find('#id-name').exists()).toBe(false)
// ↑ #id-name: CSS ID セレクタ（ハッシュ記法）
// ↑ false: 要素が存在しないことを期待

// 要素の表示・非表示確認
expect(wrapper.find('.element').isVisible()).toBe(true)
// ↑ .isVisible(): CSS の display プロパティなどで要素が視覚的に表示されているかを確認
// ↑ exists() と isVisible() の違い: DOM に存在しても非表示の場合がある

expect(wrapper.find('.hidden').isVisible()).toBe(false)
// ↑ .hidden: 非表示要素のクラス名
// ↑ display: none や visibility: hidden の要素は false

// 要素数の確認
expect(wrapper.findAll('.item').length).toBe(3)
// ↑ findAll(): 条件に一致する全ての要素を配列で取得
// ↑ .length: JavaScript 配列の長さプロパティ
// ↑ .toBe(3): 要素が3個あることを期待

expect(wrapper.findAll('li')).toHaveLength(5)
// ↑ toHaveLength(): Jest の配列長チェック専用マッチャー
// ↑ .toBe(array.length) と同じ意味だが、より読みやすい
```

### 2.2 テキスト・属性確認の文法

```javascript
// テキスト内容の確認
expect(wrapper.find('h1').text()).toBe('タイトル')
// ↑ wrapper.find('h1'): h1 タグを検索
// ↑ .text(): 要素のテキスト内容を文字列として取得
// ↑ innerHTML ではなく、表示されるテキストのみ

expect(wrapper.text()).toContain('含まれる文字列')
// ↑ wrapper.text(): コンポーネント全体のテキスト内容
// ↑ .toContain(): 部分文字列が含まれているかを確認
// ↑ 完全一致ではなく、部分一致でOK

// HTML内容の確認
expect(wrapper.find('.content').html()).toContain('<span>')
// ↑ .html(): 要素の HTML 内容を文字列として取得
// ↑ タグを含む完全な HTML 構造を取得
// ↑ '<span>': HTML タグが含まれているかを確認

// 属性確認
expect(wrapper.find('input').attributes('type')).toBe('text')
// ↑ .attributes(): HTML 属性の値を取得
// ↑ 'type': 取得したい属性名を指定
// ↑ 'text': input type="text" であることを確認

expect(wrapper.find('button').attributes('disabled')).toBe('disabled')
// ↑ disabled: ブール属性の場合、存在すれば属性名と同じ値を返す
// ↑ 属性が存在しない場合は undefined を返す

// CSS クラスの確認
expect(wrapper.find('.button').classes()).toContain('active')
// ↑ .classes(): 要素のクラス名を配列として取得
// ↑ .toContain('active'): 'active' クラスが含まれているかを確認

expect(wrapper.find('.button').classes('active')).toBe(true)
// ↑ .classes('active'): 特定のクラスが存在するかを真偽値で返す
// ↑ 上記の .toContain() より簡潔な書き方
```

### 2.3 フォーム要素の文法

```javascript
// input 要素の値確認
expect(wrapper.find('input').element.value).toBe('入力値')
// ↑ .element: Vue Test Utils のラッパーから実際の DOM 要素を取得
// ↑ .value: HTML input 要素の value プロパティ
// ↑ Vue のデータと実際の DOM の値は異なる場合があるため element を使用

// select 要素の選択値確認
expect(wrapper.find('select').element.value).toBe('option1')
// ↑ select の value は選択された option の value 属性値

// checkbox の状態確認
expect(wrapper.find('input[type="checkbox"]').element.checked).toBe(true)
// ↑ input[type="checkbox"]: CSS 属性セレクタ
// ↑ .checked: checkbox の選択状態を真偽値で取得
// ↑ チェックされていれば true、そうでなければ false

// radio button の状態確認
expect(wrapper.find('input[type="radio"]').element.checked).toBe(false)
// ↑ radio button も .checked プロパティで選択状態を確認
// ↑ 複数の radio button がある場合は、適切なセレクタで絞り込む
```

## 🖱️ 3. DOM操作とイベントの文法解説

### 3.1 基本的なイベントの文法

```javascript
// クリックイベントの発火
await wrapper.find('button').trigger('click')
// ↑ await: trigger() は Promise を返すため非同期待ち
// ↑ .trigger(): 指定した DOM イベントを発火させる
// ↑ 'click': イベント名を文字列で指定

// input イベントの発火（値の設定と同時）
await wrapper.find('input').setValue('新しい値')
// ↑ .setValue(): input 要素に値を設定し、input イベントも発火
// ↑ 手動で .trigger('input') を呼ぶ必要がない

// change イベントの発火
await wrapper.find('select').setValue('option2')
// ↑ select 要素の場合、setValue() で change イベントも発火

// フォーム送信イベント
await wrapper.find('form').trigger('submit')
// ↑ form 要素の submit イベントを発火
// ↑ preventDefault() の動作もテスト可能

// キーボードイベント（オプション付き）
await wrapper.find('input').trigger('keydown', { key: 'Enter' })
// ↑ 第2引数: イベントオブジェクトのプロパティを指定
// ↑ { key: 'Enter' }: KeyboardEvent の key プロパティを設定
```

### 3.2 フォーム操作の詳細文法

```javascript
// テキスト入力の操作
const input = wrapper.find('input[type="text"]')
// ↑ const: 要素への参照を定数として保存
// ↑ 後続の操作で同じ要素を複数回操作する場合の効率化

await input.setValue('テスト入力')
// ↑ 保存した要素参照を使用してメソッド呼び出し

// チェックボックスの操作
const checkbox = wrapper.find('input[type="checkbox"]')
await checkbox.setChecked(true)
// ↑ .setChecked(): checkbox の選択状態を設定
// ↑ true: チェック状態にする
// ↑ false: チェックを外す

// ラジオボタンの操作
const radio = wrapper.find('input[type="radio"][value="option1"]')
// ↑ [value="option1"]: 特定の値を持つ radio button を選択
await radio.setChecked()
// ↑ radio button の場合、引数なしで setChecked() を呼ぶ

// セレクトボックスの基本操作
const select = wrapper.find('select')
await select.setValue('option2')
// ↑ option の value 属性値を指定して選択

// セレクトボックスの複数選択
const options = wrapper.find('select').findAll('option')
// ↑ select 内の全ての option 要素を取得
await options.at(1).setSelected()
// ↑ .at(1): 配列の2番目の要素を取得（0から始まる）
// ↑ .setSelected(): option を選択状態にする
```

### 3.3 プルダウン操作の詳細文法

```javascript
// プルダウンの全選択肢取得
const options = wrapper.find('select[name="dropdown"]').findAll('option')
// ↑ select[name="dropdown"]: name 属性で特定の select を選択
// ↑ findAll('option'): 内部の全ての option 要素を取得

// 特定のテキストで選択肢を検索
const targetOption = options.filter(node => node.text() === '選択したい値')
// ↑ .filter(): 配列の絞り込みメソッド
// ↑ node => node.text() === '選択したい値': アロー関数で条件指定
// ↑ node.text(): 各 option のテキスト内容を取得

await targetOption.at(0).setSelected()
// ↑ filter の結果から最初の要素を取得して選択
// ↑ 通常、text で絞り込んだ場合は1つだけマッチする

// 値で直接選択（より簡潔な方法）
await wrapper.find('select').setValue('value1')
// ↑ option の value 属性値で直接選択
// ↑ テキストではなく value で選択する場合

// 選択肢の数と内容の確認
expect(options.length).toBe(5)
// ↑ 選択肢の総数を確認
expect(options.at(0).text()).toBe('オプション1')
// ↑ 特定の位置の選択肢のテキストを確認
```

## ⚡ 4. 非同期処理の文法解説

### 4.1 Vue更新待ちの文法

```javascript
// Vue の DOM 更新を待つ
await wrapper.vm.$nextTick()
// ↑ wrapper.vm: Vue インスタンスへの参照
// ↑ $nextTick(): Vue の次の DOM 更新サイクルまで待機
// ↑ await: Promise の完了を待つ
// ↑ データ変更後の DOM 反映を確実に待つために必要

// 全ての Promise の完了を待つ
import flushPromises from 'flush-promises'
// ↑ 外部ライブラリをインポート（npm install flush-promises）

await flushPromises()
// ↑ 現在のマイクロタスクキュー内のすべての Promise を実行
// ↑ API 呼び出しなどの非同期処理の完了を待つ

// タイマー処理を進める
jest.advanceTimersByTime(1000)
// ↑ Jest のフェイクタイマー使用時
// ↑ 指定したミリ秒分タイマーを進める
// ↑ setTimeout や setInterval の動作をシミュレート
```

### 4.2 API呼び出しテストの文法

```javascript
// API モックの設定
const mockApiCall = jest.fn().mockResolvedValue({ data: 'test' })
// ↑ jest.fn(): Jest のモック関数を作成
// ↑ .mockResolvedValue(): Promise.resolve() を返すモック
// ↑ { data: 'test' }: 返却される値

// Vue インスタンスにモックを注入
wrapper.vm.$api = { getData: mockApiCall }
// ↑ wrapper.vm: Vue インスタンスへの直接アクセス
// ↑ $api: カスタムプロパティ（アプリケーション固有）
// ↑ { getData: mockApiCall }: メソッド名とモックのマッピング

// コンポーネントのメソッド実行
await wrapper.vm.fetchData()
// ↑ Vue インスタンスのメソッドを直接呼び出し
// ↑ 非同期メソッドなので await で待機

// モックの呼び出し確認
expect(mockApiCall).toHaveBeenCalledTimes(1)
// ↑ .toHaveBeenCalledTimes(): 呼び出し回数を確認
// ↑ 1: 1回だけ呼ばれたことを期待

expect(mockApiCall).toHaveBeenCalledWith({ id: 1 })
// ↑ .toHaveBeenCalledWith(): 呼び出し時の引数を確認
// ↑ { id: 1 }: 期待される引数オブジェクト
```

## 🎭 5. モック・スタブの文法解説

### 5.1 Vuex ストアモックの文法

```javascript
// Vuex ストアのモックオブジェクト作成
const mockStore = {
// ↑ const: オブジェクトリテラルでモックを定義

  // getters のモック
  getters: {
  // ↑ Vuex の getters を模擬するオブジェクト

    // getter 関数のモック
    currentUser: () => ({ name: 'テストユーザー' }),
    // ↑ currentUser: getter の名前
    // ↑ () => ({ ... }): アロー関数で返却値を定義
    // ↑ ({ name: 'テストユーザー' }): 返却されるオブジェクト

    isLoggedIn: () => true
    // ↑ 真偽値を返すシンプルな getter
  },

  // actions/mutations のモック
  dispatch: jest.fn(),
  // ↑ dispatch: Vuex の action 実行メソッド
  // ↑ jest.fn(): モック関数（呼び出し履歴を記録）

  commit: jest.fn()
  // ↑ commit: Vuex の mutation 実行メソッド
}

// コンポーネントマウント時にモックを注入
const wrapper = mount(Component, {
  mocks: {
    $store: mockStore
    // ↑ $store: Vue インスタンスの this.$store をモック
  }
})
```

### 5.2 Vue Router モックの文法

```javascript
// Vue Router のモックオブジェクト
const mockRouter = {
// ↑ router のメソッドをモック関数で置き換え

  push: jest.fn(),
  // ↑ push: 新しいルートに遷移するメソッド
  // ↑ jest.fn(): 実際の遷移はせず、呼び出しのみ記録

  replace: jest.fn(),
  // ↑ replace: 現在のルートを置き換える

  go: jest.fn()
  // ↑ go: 履歴を戻る/進むメソッド
}

// route 情報のモック
const mockRoute = {
// ↑ 現在のルート情報を模擬

  params: { id: '123' },
  // ↑ params: ルートパラメータ（/user/:id の :id 部分）

  query: { tab: 'profile' },
  // ↑ query: クエリパラメータ（?tab=profile の部分）

  path: '/user/123'
  // ↑ path: 現在のパス
}

// モックの注入
const wrapper = mount(Component, {
  mocks: {
    $router: mockRouter,  // this.$router をモック
    $route: mockRoute     // this.$route をモック
  }
})
```

### 5.3 メソッドモックの文法

```javascript
// コンポーネントメソッドのモック
wrapper.vm.expensiveMethod = jest.fn().mockReturnValue('mocked result')
// ↑ wrapper.vm.expensiveMethod: 既存のメソッドを置き換え
// ↑ jest.fn(): モック関数を作成
// ↑ .mockReturnValue(): 戻り値を固定値に設定
// ↑ 'mocked result': 常にこの値を返す

// 外部ライブラリのモック
jest.mock('axios')
// ↑ jest.mock(): モジュール全体をモック化
// ↑ 'axios': モック対象のモジュール名

const mockedAxios = axios as jest.Mocked<typeof axios>
// ↑ TypeScript の型アサーション
// ↑ jest.Mocked<typeof axios>: axios のモック型

mockedAxios.get.mockResolvedValue({ data: { result: 'success' } })
// ↑ .get: axios の GET メソッド
// ↑ .mockResolvedValue(): Promise.resolve() を返すモック
// ↑ { data: { result: 'success' } }: axios のレスポンス形式
```

## 🔍 6. セレクタ文法の詳細解説

```javascript
// CSS セレクタの基本
wrapper.find('.class-name')    // クラスセレクタ
// ↑ .: クラスを示すCSS記法

wrapper.find('#id-name')       // IDセレクタ
// ↑ #: IDを示すCSS記法

wrapper.find('tag-name')       // タグセレクタ
// ↑ タグ名をそのまま指定

wrapper.find('[data-test="selector"]')  // 属性セレクタ
// ↑ [属性名="値"]: 特定の属性値を持つ要素

// 複合セレクタ
wrapper.find('input[type="text"]')      // タグ + 属性
// ↑ input要素かつtype属性がtextの要素

wrapper.find('button[disabled]')        // 属性の存在確認
// ↑ disabled属性を持つbutton要素

wrapper.find('select[name="dropdown"]') // タグ + name属性
// ↑ select要素かつname属性がdropdownの要素

// Vue コンポーネントの検索
wrapper.findComponent({ name: 'ChildComponent' })
// ↑ findComponent(): Vue コンポーネントを検索
// ↑ { name: 'ChildComponent' }: コンポーネント名で検索

wrapper.findComponent(ChildComponent)
// ↑ コンポーネントクラス/オブジェクトで直接検索

// 複数要素の操作
wrapper.findAll('.item')       // 全ての該当要素
// ↑ findAll(): 条件に一致する全要素を配列で取得

wrapper.findAll('li').at(0)    // 配列の特定位置
// ↑ .at(0): 配列の最初の要素を取得

// テキスト内容での絞り込み
wrapper.findAll('button').filter(node => node.text() === 'クリック')
// ↑ .filter(): 配列をフィルタリング
// ↑ node => node.text() === 'クリック': 条件関数
```

この文法解説を参考に、Vue.jsテストコードの「なぜそう書くのか」を理解して、より効果的なテストを書いてください！
